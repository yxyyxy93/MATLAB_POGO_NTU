function [nodePos] = pipeSurfaceProfile(model,surface, Rin, Rout, dTh, d)
%% Add surface roughness based on profile that gives value at each circumferential and axial position 
% Apply to a structured mesh such as that generated by genGridPipe.m
% Surface profile may be as a deviation from the current surface of the
% mesh as generated by genGridPipe or given as a radius to each surface point.
% 
% model   = output from genGridPipe.m
% surface = Information about surface
%   surface.inner.fN = inner profile filename
%   surface.outer.fN = outer profile filename
%   surface.inner.type = Is surface given as 'radius' to points or 'deviation' from Rout
%   surface.outer.type = Is surface given as 'radius' to points or 'deviation' from Rout
%   surface.deformationLimit = What is the maximum amount that elements can deform as a fraction of the original size   
% Rin     = inner radius
% Rout    = outer radius
% dTh     = angular spacing (radians)
% d       = element size (metres)
%
% nodePos = output modified node positions
%
%   Sam Horne (2019)
%   sjh415@ic.ac.uk

%% Load profiles
[surface.outer.radius,surface.outer.deviation] = pipeSurfaceProfile_loadSurface(surface.outer.fN,Rout,surface.outer.type,d);
[surface.inner.radius,surface.inner.deviation] = pipeSurfaceProfile_loadSurface(surface.inner.fN,Rin,surface.inner.type,d);

%% Get angle to nodes. This should be the same for each z slice (within some very small tolerance)
% Angle to nodes at the first z position
zU = unique(model.nodePos(3,:));
th = atan2(model.nodePos(2,model.nodePos(3,:)==zU(1)),model.nodePos(1,model.nodePos(3,:)==zU(1)));
thU = uniquetol(th,dTh/3,'DataScale', 1);

nodePos = model.nodePos;
%% Modify node positions
% Loop along z slices
for nZ=1:length(zU)
    % Skip position if there is no change at this nz location
    if max(surface.outer.deviation(nZ,:)) ~= 0 || max(surface.inner.deviation(nZ,:)) ~= 0
        % get slice of nodes at this z location
        tempL_z = find(model.nodePos(3,:)==zU(nZ));
        
        % Loop over th positions
        for nTh = 1:length(thU)
            % Skip position if no change to make at this nz,nth
            if surface.outer.deviation(nZ,nTh) ~= 0 || surface.inner.deviation(nZ,nTh) ~= 0 
                tempL_z_th = find( abs(th - thU(nTh)) < dTh/3 ); %  nodes at this (z,th) location
                
                % original radius of points at this z,th location
                r = sqrt(model.nodePos(2,tempL_z(tempL_z_th)).^2+model.nodePos(1,tempL_z(tempL_z_th)).^2);
                
                % Depth of nodes that need to be modified to keep
                % the element deformation below surface.deformationLimit
                outerDepthModified = surface.outer.deviation(nZ,nTh)/(surface.deformationLimit);
                innerDepthModified = surface.inner.deviation(nZ,nTh)/(surface.deformationLimit);
                
                % If total depth modified is greater than wall thickness
                % throw an error
                if outerDepthModified + innerDepthModified > (Rout-Rin)
                    error('Profile has too much variation to be implemented with the current deforamtion limit at nth = %g, nc = %g\n',nTh,nZ)
                end
                
                % Start radius for modification of each surface
                outerStart = Rout-abs(outerDepthModified);
                innerStart = Rin+abs(innerDepthModified);
               
                %% Modify outer nodes if needed
                if surface.outer.deviation(nZ,nTh) ~= 0
                    tempL_z_th_r = find(r>=outerStart);
                    
                    % new Radius of points at this z,th location
                    R = outerStart + (r(tempL_z_th_r)-outerStart)/(Rout-outerStart).*(surface.outer.radius(nZ,nTh)-outerStart);
                    
                    % convert back to cartesian coordinates for pogo
                    nodePos(1,tempL_z(tempL_z_th(tempL_z_th_r))) = cos(thU(nTh)).*R;
                    nodePos(2,tempL_z(tempL_z_th(tempL_z_th_r))) = sin(thU(nTh)).*R;
                end
                %% Modify inner nodes if needed
                if surface.inner.deviation(nZ,nTh) ~= 0
                    tempL_z_th_r = find(r<=innerStart);
                    
                    %new Radius of points at this z,th location
                    R = innerStart - (innerStart-r(tempL_z_th_r))/(innerStart-Rin).*(innerStart-surface.inner.radius(nZ,nTh));
                    
                    %convert back to cartesian coordinates
                    nodePos(1,tempL_z(tempL_z_th(tempL_z_th_r))) = cos(thU(nTh)).*R;
                    nodePos(2,tempL_z(tempL_z_th(tempL_z_th_r))) = sin(thU(nTh)).*R;
                end       
            end
        end
    end
end

return